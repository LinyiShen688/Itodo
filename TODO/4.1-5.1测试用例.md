# UnifiedStorage 测试用例

# 1.测试场景：未登录用户测试

## 1.1测试用例-新增：
### 1.1.1操作：
未登录状态下，新建两个任务列表a和b，每个任务列表里面建各个象限各1任务，比如a1任务就是就是在任务列表a的第一象限，a2就是就是在任务列表a的第二象限，b1任务就是就是在任务列表b的第一象限，以此类推；

### 1.1.2期望：
（1）[ ] 未登录方案下，可以正常建任务列表和任务并可以正常显示，
（2）[ ] 任务列表和任务的 userId 都为 null

## 1.2测试用例-删除：
### 1.2.1操作：
a任务列表：
- 删除a3任务进入收纳箱；
- 删除a4任务进入收纳箱，再从收纳箱删除a4任务，使得a4任务进入墓碑状态；

b任务列表：直接删除b任务列表

### 1.2.2期望：
（1）[ ] a任务列表：
- a1和a2的deleted字段为0
- a3的deleted字段为1
- a4的deleted字段为2

（2）[ ] b任务列表
- b的deleted字段为2，b任务列表下的所有子任务的deleted字段为2

## 1.3测试用例-更新：
### 1.3.1操作：
- 修改a1任务文本为"更新后的a1"
- 切换a2任务完成状态
- 将b2从第2象限移动到第3象限

### 1.3.2期望：
（1）[ ] a1任务的text更新成功
（2）[ ] a2任务的completed字段从0变为1
（3）[ ] b2任务的quadrant从2变为3

## 1.4测试用例-恢复：
### 1.4.1操作：
- 创建新任务a5并删除到收纳箱
- 从收纳箱恢复a5任务

### 1.4.2期望：
（1）[ ] a5任务从deleted=1变为deleted=0
（2）[ ] a5任务在主界面正常显示

# 2.测试场景：登录后数据同步测试

## 2.1测试用例-登录迁移：
### 2.1.1操作：
使用测试账号登录

### 2.1.2期望：
（1）[ ] 所有userId为null的数据更新为当前用户ID
（2）[ ] syncQueue表中生成相应的add操作记录
（3）[ ] 数据成功同步到云端

## 2.2测试用例-同步验证：
### 2.2.1操作：
登录后创建新任务和更新现有任务

### 2.2.2期望：
（1）[ ] 操作立即反映在UI上
（2）[ ] syncQueue表中生成对应记录
（3）[ ] 网络请求成功发送到Supabase

# 2.测试场景：其他设备登录后数据同步

## 2.1测试用例-登录迁移：
### 2.1.1操作：
用其他设备使用测试账号登录

### 2.1.2期望：
（1）[ ] 云端数据拉到设备中
（2）[ ] 存在两条任务列表，由用户决定保留哪一个

## 2.2测试用例-同步验证：
### 2.2.1操作：
登录后创建新任务和更新现有任务

### 2.2.2期望：
（1）[ ] 操作立即反映在UI上
（2）[ ] syncQueue表中生成对应记录
（3）[ ] 网络请求成功发送到Supabase


# 3.测试场景：离线/在线切换测试

## 3.1测试用例-离线操作：
### 3.1.1操作：
- 登录状态下断开网络
- 创建新任务c1
- 更新任务c1文本
- 删除任务c1

### 3.1.2期望：
（1）[ ] 所有操作在UI上立即生效
（2）[ ] syncQueue表中生成pending状态的记录
（3）[ ] 无网络请求发出

## 3.2测试用例-网络恢复：
### 3.2.1操作：
恢复网络连接

### 3.2.2期望：
（1）[ ] 自动开始处理同步队列
（2）[ ] pending记录变为processing再变为completed
（3）[ ] 数据成功同步到云端

1.激活任务列表失败保唯一性约束冲突，已改好，待测
原因：
从indexeddb数据库的getAll（），找到返回的数据是无序的，或者说是按照 UUU ID 排序的，但是 UUU ID 非=v4也是无需的。所以返回的数据就是无序的。
通过加createAt排序数据，
后续又发现添加任务到同步序列的时候一毫秒内全部完成了，然后utc呢，只能精确到毫秒，所以两个或多个任务的createAT时间戳是一样的，又通过加一毫秒睡眠来解决时间戳一致问题
2.点击空白添加任务，我同步训练加了一个ATP又加了一个Update；
原因：以前的方法里，点击空白区域的时候，立即就往同步序列里面加一个空白字符串的任务了。后续的增加文本用的是 update，然后再往同步序列里面加一个 up date 的同步序列。

# 4.测试场景：多设备同步测试

## 4.1测试用例-多设备冲突：
### 4.1.1操作：
- 设备A：修改任务d1文本为"设备A的修改"
- 设备B：同时修改任务d1文本为"设备B的修改"
- 两个设备都执行同步

bug:
1.由于本地也有一个默认的任务列表，所以在拉群云端数据的时候和同步数据到云端时候云端会出现两个默认任务列表，只是有的时候可能两个默认任务列表的意思，isActive状态都是都是激活状态，所以就会报云端数据库的唯一性约束问题
解决在同步的时候，默认把本地的所有数据都置为的就是所有的任务列表的状态都置为0,上传到云端的数据也动至为零；

### 4.1.2期望：
（1）[ ] 后修改的设备数据覆盖先修改的（LWW策略）
（2）[ ] 被覆盖设备的syncQueue中相关记录被清理
（3）[ ] 两设备最终数据一致



# 5.测试场景：同步队列管理测试

## 5.1测试用例-失败重试：
### 5.1.1操作：
- 制造同步失败（如临时断网）
- 观察重试行为
- 手动重试失败项

### 5.1.2期望：
（1）[ ] 自动重试最多3次
（2）[ ] 失败后状态变为failed
（3）[ ] 手动重试功能正常

# 6.测试场景：用户切换测试

## 6.1测试用例-登出隔离：
### 6.1.1操作：
- 用户A登录并创建数据
- 登出
- 未登录状态创建新数据

### 6.1.2期望：
（1）[ ] 登出后新创建的数据userId为null
（2）[ ] 用户A的数据不受影响
（3）[ ] syncQueue停止处理

## 6.2测试用例-账号切换：
### 6.2.1操作：
- 用户A登出
- 用户B登录

### 6.2.2期望：
（1）[ ] 只能看到用户B的数据
（2）[ ] userId为null的本地数据迁移到用户B
（3）[ ] 用户A的数据完全隔离

# 7.测试场景：异常恢复测试

## 7.1测试用例-浏览器刷新：
### 7.1.1操作：
- 创建任务后立即刷新页面（同步未完成）

### 7.1.2期望：
（1）[ ] 数据不丢失
（2）[ ] syncQueue记录保留
（3）[ ] 刷新后继续同步

## 7.2测试用例-同步中断：
### 7.2.1操作：
- 大量操作后开始同步
- 同步过程中关闭浏览器
- 重新打开应用

### 7.2.2期望：
（1）[ ] 已完成的同步不重复
（2）[ ] 未完成的同步继续处理
（3）[ ] 数据最终一致

# 8.测试场景：边界和性能测试

## 8.1测试用例-大量数据：
### 8.1.1操作：
- 创建50个任务
- 批量更新20个任务
- 批量删除10个任务

### 8.1.2期望：
（1）[ ] UI响应流畅无卡顿
（2）[ ] syncQueue正确记录所有操作
（3）[ ] 同步完成时间在合理范围内

## 8.2测试用例-并发操作：
### 8.2.1操作：
快速连续执行多个操作（不等待前一个完成）

### 8.2.2期望：
（1）[ ] 所有操作都被正确记录
（2）[ ] 数据最终状态正确
（3）[ ] 无数据丢失或重复

# 9.测试场景：数据验证测试

## 9.1测试用例-外键约束：
### 9.1.1操作：
尝试在已删除（deleted=2）的列表中创建任务

### 9.1.2期望：
（1）[ ] 操作被拒绝
（2）[ ] 显示适当的错误提示

## 9.2测试用例-数据格式：
### 9.2.1操作：
检查同步前后的数据格式转换

### 9.2.2期望：
（1）[ ] 布尔值正确转换（0/1 ↔ true/false）
（2）[ ] 字段名正确转换（驼峰 ↔ 下划线）
（3）[ ] 时间戳保持UTC格式

# 10.测试场景：同步状态UI测试

## 10.1测试用例-同步进度显示：
### 10.1.1操作：
打开同步进度弹窗查看状态

### 10.1.2期望：
（1）[ ] 正确显示pending/processing/completed/failed状态
（2）[ ] 失败项显示错误原因
（3）[ ] 可以手动重试和删除队列项